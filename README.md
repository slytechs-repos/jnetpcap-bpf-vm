# JNetRuntime BPF VM

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Build Status](https://img.shields.io/badge/build-passing-brightgreen.svg)]()
[![Java Version](https://img.shields.io/badge/java-%3E%3D%208-orange.svg)]()

A high-performance Berkeley Packet Filter (BPF) Virtual Machine implementation in Java that provides both kernel BPF compatibility and extensible runtime OPCODE support.

## Overview

JNetRuntime BPF VM is a versatile implementation of the Berkeley Packet Filter virtual machine that can:

- Execute standard BPF bytecode generated by tcpdump and other tools
- Support runtime-loadable custom OPCODES for extended functionality
- Run in both user space and kernel space contexts
- Process network packets at line rate with minimal overhead
- Integrate with the jnetruntime-bpf-compiler for full filter expression support

## Features

### Core Capabilities

- **Full BPF Instruction Set**: Supports all standard BPF instructions including:
  - Load/Store operations
  - Branch operations
  - ALU operations
  - Return operations
  - Memory operations

- **Binary Compatibility**
  ```java
  // Execute BPF bytecode directly from tcpdump
  byte[] tcpdumpBytecode = getTcpdumpBytecode("tcp port 80");
  BPFProgram program = BPFProgram.load(tcpdumpBytecode);
  boolean matches = program.execute(packet);
  ```

- **Runtime OPCODE Extension**
  ```java
  // Register custom OPCODE
  BPFVirtualMachine.registerOpcode(0xF0, new CustomBPFInstruction());
  
  // Use in programs
  BPFProgram program = BPFProgram.builder()
      .addInstruction(new CustomBPFInstruction(args))
      .build();
  ```

- **High Performance**
  - Zero-copy packet processing
  - Optimized instruction dispatch
  - Minimal object allocation
  - Thread-safe execution

### Integration with BPF Compiler

The VM works seamlessly with [jnetruntime-bpf-compiler](link-to-compiler) to support multiple filter expression dialects:

```java
// Compile and execute filter expressions
String filter = "ip and tcp port 80";
BPFCompiler compiler = new BPFCompiler();

// Compile to BPF bytecode
byte[] bytecode = compiler.compile(filter);

// Execute in VM
BPFProgram program = BPFProgram.load(bytecode);
boolean matches = program.execute(packet);

// Or execute directly in kernel (when available)
KernelBPF.load(bytecode);
```

## Installation

Add the following dependency to your `pom.xml`:

```xml
<dependency>
    <groupId>io.github.jnetruntime</groupId>
    <artifactId>jnetruntime-bpf-vm</artifactId>
    <version>${latest.version}</version>
</dependency>
```

For the compiler module:

```xml
<dependency>
    <groupId>io.github.jnetruntime</groupId>
    <artifactId>jnetruntime-bpf-compiler</artifactId>
    <version>${latest.version}</version>
</dependency>
```

## Usage Examples

### Basic Packet Filtering

```java
// Create VM instance
BPFVirtualMachine vm = new BPFVirtualMachine();

// Load program from bytecode
byte[] bytecode = {/* BPF instructions */};
BPFProgram program = BPFProgram.load(bytecode);

// Process packet
byte[] packet = getPacket();
boolean matches = program.execute(packet);
```

### Using Filter Expressions

```java
// Create compiler instance
BPFCompiler compiler = new BPFCompiler();

// Compile filter expression
String filter = "tcp and (dst port 80 or dst port 443)";
byte[] bytecode = compiler.compile(filter);

// Create and execute program
BPFProgram program = BPFProgram.load(bytecode);
boolean matches = program.execute(packet);
```

### Custom OPCODE Extension

```java
// Define custom instruction
public class CustomInstruction implements BPFInstruction {
    @Override
    public int execute(BPFContext ctx) {
        // Implementation
    }
}

// Register with VM
BPFVirtualMachine.registerOpcode(0xF0, new CustomInstruction());

// Use in programs
BPFProgram program = BPFProgram.builder()
    .addInstruction(new LoadInstruction(0))
    .addInstruction(new CustomInstruction())
    .addInstruction(new ReturnInstruction(0))
    .build();
```

### Kernel Integration

```java
// Check kernel BPF availability
if (KernelBPF.isAvailable()) {
    // Load and execute in kernel
    int fd = KernelBPF.load(bytecode);
    boolean matches = KernelBPF.execute(fd, packet);
} else {
    // Fall back to VM
    BPFProgram program = BPFProgram.load(bytecode);
    boolean matches = program.execute(packet);
}
```

## Architecture

The BPF VM consists of several key components:

1. **Virtual Machine Core**
   - Instruction decoder
   - Execution engine
   - Register set
   - Memory management

2. **OPCODE Registry**
   - Standard BPF instructions
   - Extension mechanism
   - Runtime registration

3. **Program Management**
   - Bytecode loading
   - Program validation
   - Execution context

4. **Kernel Integration**
   - Native BPF support
   - Fallback mechanisms
   - Performance optimizations

## Performance

Benchmarks show performance comparable to native implementations:

- Throughput: > 1M packets/second on modern hardware
- Latency: < 1Î¼s per packet for typical filters
- Memory: < 1KB per program instance

## Building from Source

```bash
git clone https://github.com/jnetruntime/jnetruntime-bpf-vm.git
cd jnetruntime-bpf-vm
mvn clean install
```

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

Key areas for contribution:
- Additional instruction implementations
- Performance optimizations
- Platform-specific enhancements
- Documentation improvements

## License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.

## Related Projects

- [jnetruntime-bpf-compiler](link-to-compiler) - BPF filter expression compiler
- [jnetruntime-core](link-to-core) - Core networking utilities
- [jnetruntime-native](link-to-native) - Native integration components

## Contact

- GitHub Issues: [Project Issues](link-to-issues)
- Mailing List: [jnetruntime-dev@googlegroups.com](mailto:jnetruntime-dev@googlegroups.com)
- Slack: [#jnetruntime](link-to-slack)

## Acknowledgments

- Berkeley Packet Filter (BPF) original authors
- tcpdump project contributors
- Linux eBPF developers
